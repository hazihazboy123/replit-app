  var alreadyRendered = false;

    function processSelective1b1() {
      if (alreadyRendered) return;
      // parse the cloze numbers for which selectiveOneByOne is enabled
      var clozeNumbers = document.getElementById("one-by-one").textContent.split(',').filter(element => element).map(Number)
      var cardNumberIsOneByOne =!clozeNumbers.filter(n =>!Number.isNaN(n)).length |
| clozeNumbers.includes(parseInt(getCardNumber()))

      // check the amount of clozes -> disable OneByOne if less than minimum value wanted (minNumberOfClozes)
      var numClozesForNumber = (minNumberOfClozes)? document.querySelectorAll('.clozefield.cloze').length : 0

      // stop OneByOne if selectiveOneByOne is not enabled for this specific card OR if OneByOne is disabled some other way
      // -> show normal backside
      if (!alwaysOneByOne && ((selectiveOneByOne &&!cardNumberIsOneByOne) |
| (oneByOneFieldNotEmpty && (numClozesForNumber < minNumberOfClozes)))) {
        clozeOneByOneEnabled = false
      }

      if (autoflip && clozeOneByOneEnabled) {

    if(window.pycmd |
| window.showAnswer) {
        // avoid flickering. Must unset this in the back.
        document.getElementById("qa").style.display = "none";
    }

    if (window.pycmd) {
        pycmd("ans")
    } else if (window.showAnswer) {
        showAnswer()
    }
}
// AnkiMobile JS API doesn't have one for show answer.
// Best alternative is to use Taps/Swipes to show answer.

      alreadyRendered = true;
    }

    function delayedProcessSelective1b1() {
      if (window.requestAnimationFrame) window.requestAnimationFrame(processSelective1b1); // less flickering
      else window.setTimeout(processSelective1b1, 0);
    };

    window.onload = delayedProcessSelective1b1;
    if (document.readyState === "complete") {
      delayedProcessSelective1b1();
    }
    else {
      document.addEventListener("DOMContentLoaded", delayedProcessSelective1b1);
    }

    // Observe document.body class changes to trigger re-rendering.
    // This is useful, because Anki doesnâ€™t always start with an up-to-date class list:
    // https://forums.ankiweb.net/t/card-card-classes-only-injected-separately-now/27387.
    const observer = new MutationObserver(function(mutationsList, observer) {
      for (let mutation of mutationsList) {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          delayedProcessSelective1b1();
        }
      }
    });
    observer.observe(document.body, { attributes: true });
  }
  Persistence.setItem("clozeHints", clozeHints);
</script>

<script>
  if (window.ankingEventListeners) {
    for (const listener of ankingEventListeners) {
      const type = listener
      const handler = listener[1]
      document.removeEventListener(type, handler)
    }
  }
  window.ankingEventListeners =
  
  window.ankingAddEventListener = function(type, handler) {
    document.addEventListener(type, handler)
    window.ankingEventListeners.push([type, handler])
  }
</script>

<script>
  var specialCharCodes = {
    "-": "minus",
    "=": "equal",
    "[": "bracketleft",
    "]": "bracketright",
    ";": "semicolon",
    "'": "quote",
    "`": "backquote",
    "\\": "backslash",
    ",": "comma",
    ".": "period",
    "/": "slash",
  };
  // Returns function that match keyboard event to see if it matches given shortcut.
  function shortcutMatcher(shortcut) {
    let shortcutKeys = shortcut.toLowerCase().split(/[+]/).map(key => key.trim())
    let mainKey = shortcutKeys[shortcutKeys.length - 1]
    if (mainKey.length === 1) {
      if (/\\d/.test(mainKey)) {
        mainKey = "digit" + mainKey
      } else if (/[a-zA-Z]/.test(mainKey)) {
        mainKey = "key" + mainKey
      } else {
        let code = specialCharCodes[mainKey];
        if (code) {
          mainKey = code
        }
      }
    }
    let ctrl = shortcutKeys.includes("ctrl")
    let shift = shortcutKeys.includes("shift")
    let alt = shortcutKeys.includes("alt")

    let matchShortcut = function (ctrl, shift, alt, mainKey, event) {
      if (mainKey!== event.code.toLowerCase()) return false
      if (ctrl!== (event.ctrlKey |
| event.metaKey)) return false
      if (shift!== event.shiftKey) return false
      if (alt!== event.altKey) return false
      return true
    }.bind(window, ctrl, shift, alt, mainKey)
    
    return matchShortcut
  }
</script>

<script>
    for (const image of document.querySelectorAll(".blur")) {
        image.classList.add("tappable");
        image.addEventListener("click", () => {
            image.classList.toggle("blur");
        });
    }
</script>

<script>
    (() => {
        const selectors = [".shuffle"];
        const isFront = Persistence.getItem("shuffle") === null;
        const shuffleMap = Persistence.getItem("shuffle") |
| {};

        function shuffle(array, indexMap) {
            let currentIndex = array.length;
            while (currentIndex!= 0) {
                currentIndex--;
                let randomIndex = indexMap[currentIndex]!== undefined ? indexMap[currentIndex] : Math.floor(Math.random() * (currentIndex + 1));
                indexMap[currentIndex] = randomIndex;
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex],
                    array[currentIndex];
            }
        }

        function shuffleElements(elements) {
            elements = elements.filter(e =>!e.matches(".no-shuffle *"));
            const shuffledElements = Array.from(
                elements.map((el) => el.cloneNode(true))
            );
            if(shuffledElements.length === 0) {
                return;
            }
            // Assuming elements is not also the first element in a different list to shuffle
            const indexMap = shuffleMap[elements] |
| {};
            shuffle(shuffledElements, indexMap);
            shuffleMap[elements] = indexMap;
            for (let i = 0; i < elements.length; i++) {
                elements[i].replaceWith(shuffledElements[i]);
            }
        }

        function shuffleList(listElement) {
            const items = Array.from(listElement.querySelectorAll("li"));
            shuffleElements(items);
        }

        for (const selector of selectors) {
            for (const container of document.querySelectorAll(selector)) {
                if (["UL", "OL"].includes(container.tagName)) {
                    shuffleList(container);
                }
                for (const parentElement of container.querySelectorAll(
                    "ol, ul"
                )) {
                    shuffleList(parentElement);
                }
                const images = Array.from(container.querySelectorAll("img"));
                shuffleElements(images);
            }
        }
        if(isFront) {
            Persistence.setItem("shuffle", shuffleMap);
        } else {
            Persistence.removeItem("shuffle");
        }
    })();
</script>

<div class="timer" id="s2"></div>
<script>
  function countdown(elementName, minutes, seconds) {
    var element, endTime, mins, msLeft, time;
    function twoDigits( n ) {
      return (n <= 9? "0" + n : n); 
    }
    function updateTimer() {
      msLeft = endTime - (+new Date);
      
      if ( msLeft < 1000 ) {
        element.innerHTML = timeOverMsg;
      } else {
        time = new Date( msLeft );
        mins = time.getUTCMinutes();
        element.innerHTML = mins + ':' + twoDigits(time.getUTCSeconds());
        setTimeout( updateTimer, time.getUTCMilliseconds() + 500 );
      }
    }
    element = document.getElementById(elementName);
    endTime = (+new Date) + 1000 * (60*minutes + seconds) + 500;
    updateTimer();
  }
  countdown("s2", minutes, seconds ); //2nd value is the minute, 3rd is the seconds
</script>

<a href="https://www.ankingmed.com"><img src="_AnKingIcon.png" alt="The AnKing" id="pic"></a>

<script>
    //DONT FADE BETWEEN CARDS
	qFade=0; if (typeof anki!== 'undefined') anki.qFade=qFade;
</script>

{{#Tags}}
<div id="tags-container">{{clickable::Tags}}</div>
<script>
  var tagContainer = document.getElementById("tags-container")
  var tagList;
  if (tagContainer.childElementCount == 0) {
    tagList = tagContainer.innerHTML.split(" ");
    var kbdList =;
    var newTagContent = document.createElement("div");

    for (var i = 0; i < tagList.length; i++) {
      var newTag = document.createElement("kbd");
      var tag = tagList[i];
      // numTagLevelsToShow == 0 means the whole tag should be shown
      if(numTagLevelsToShow!= 0){
        tag = tag.split('::').slice(-numTagLevelsToShow).join("::");
      }
      newTag.innerHTML = tag;
      newTagContent.append(newTag)
    }
    tagContainer.innerHTML = newTagContent.innerHTML;
    tagContainer.style.cursor = "default";
  }
  else {
    tagList = Array.from(tagContainer.children).map(e => e.innerText);
  }
  globalThis.tagList = tagList.map(t => t.trim().toLowerCase());
  if (tagContainer.innerHTML.indexOf(tagID)!= -1) {
    tagContainer.style.backgroundColor = "rgba(251,11,11,.15)";
  }

  function showtags() {
    var tagContainerShortcut = document.getElementById("tags-container");

    if (tagContainerShortcut.style.display
      === "none") {
      tagContainerShortcut.style.display = "block";
    } else {
      tagContainerShortcut.style.display =
        "none";
    }
  }
  
  var isShortcut = shortcutMatcher(toggleTagsShortcut)
  ankingAddEventListener('keyup', function (e) {
      if (isShortcut(e)) {
          showtags();
      }
  });

</script>
{{/Tags}}
"""

# --- 3. Helper Function for Cloze Conversion ---
def convert_cloze_placeholder(text):
    """
    Converts [CLOZE::text] placeholders to Anki's {{c#::text}} format.
    Handles multiple clozes by incrementing the cloze number.
    """
    cloze_count = 0
    def replace_match(match):
        nonlocal cloze_count
        cloze_count += 1
        content = match.group(1)
        return f"{{{{c{cloze_count}::{content}}}}}"
    
    # Use regex to find all [CLOZE::...] and replace them
    converted_text = re.sub(r'\[CLOZE::(.*?)\]', replace_match, text)
    return converted_text

# --- 4. Define the AnKing Note Model ---
# This defines the structure of your Anki cards (fields, templates, CSS).
def get_anking_model():
    # Generate unique IDs for the model and deck
    # It's important to hardcode these after initial generation for consistency
    # You can run `python3 -c "import random; print(random.randrange(1 << 30, 1 << 31))"`
    # in your shell to get new IDs if needed.
    ANKING_MODEL_ID = 1607392319 # Example ID, replace with your generated one
    ANKING_DECK_ID = 2059400110 # Example ID, replace with your generated one

    # Define the fields for your Anki notes
    # These correspond to the fields in your JSON output
    fields =

    # Define the card templates (Front and Back HTML)
    # This is where the AnKing structure and JavaScript are integrated
    templates =split('</script>')}
                </script>
            """,
            'afmt': f"""
                {{{{FrontSide}}}}
                <hr id="answer">
                <div class="answer-text">{{{{Back}}}}</div>

                {{{{#Extra}}}}
                <div id="extra">{{{{Extra}}}}</div>
                {{{{/Extra}}}}

                {{{{#Vignette}}}}
                <div id="vignette-section">
                    <h3>Clinical Vignette</h3>
                    <div class="vignette-content">{{{{Vignette}}}}</div>
                </div>
                {{{{/Vignette}}}}

                {{{{#Mnemonic}}}}
                <div id="mnemonic-section">
                    <h3>Mnemonic</h3>
                    <div class="mnemonic-content">{{{{Mnemonic}}}}</div>
                </div>
                {{{{/Mnemonic}}}}

                {{{{#Image}}}}
                <div id="image-section">
                    <img src="{{{{Image}}}}" alt="Card Image">
                </div>
                {{{{/Image}}}}

                {ANKING_JS}
            """,
        },
        {
            'name': 'AnKing Cloze Card',
            'qfmt': f"""
                <div class="card-content">
                    <div id="text">{{{{cloze:Front}}}}</div>
                    <div class="timer" id="s2"></div>
                    <a href="https://www.ankingmed.com"><img src="_AnKingIcon.png" alt="The AnKing" id="pic"></a>
                </div>
                <script>
                    //DONT FADE BETWEEN CARDS
                    qFade=0; if (typeof anki!== 'undefined') anki.qFade=qFade;
                    // Timer script (from ANKING_JS)
                    {ANKING_JS.split('function countdown').[1]split('</script>')}
                </script>
            """,
            'afmt': f"""
                {{{{FrontSide}}}}
                <hr id="answer">
                <div class="answer-text">{{{{cloze:Back}}}}</div>

                {{{{#Extra}}}}
                <div id="extra">{{{{Extra}}}}</div>
                {{{{/Extra}}}}

                {{{{#Vignette}}}}
                <div id="vignette-section">
                    <h3>Clinical Vignette</h3>
                    <div class="vignette-content">{{{{Vignette}}}}</div>
                </div>
                {{{{/Vignette}}}}

                {{{{#Mnemonic}}}}
                <div id="mnemonic-section">
                    <h3>Mnemonic</h3>
                    <div class="mnemonic-content">{{{{Mnemonic}}}}</div>
                </div>
                {{{{/Mnemonic}}}}

                {{{{#Image}}}}
                <div id="image-section">
                    <img src="{{{{Image}}}}" alt="Card Image">
                </div>
                {{{{/Image}}}}

                {ANKING_JS}
            """,
        }
    ]

    # Create the Anki Model
    my_model = genanki.Model(
        ANKING_MODEL_ID,
        'AnKing-Like Medical Flashcards',
        fields=fields,
        templates=templates,
        css=ANKING_CSS
    )
    return my_model, ANKING_DECK_ID

# --- 5. Main Function to Create Deck ---
def create_anki_deck(cards_data, output_filename="AnKing_Medical_Deck.apkg"):
    my_model, ANKING_DECK_ID = get_anking_model()
    my_deck = genanki.Deck(
        ANKING_DECK_ID,
        'My AnKing-Like Medical Deck'
    )

    media_files =

    for card_info in cards_data:
        card_type = card_info.get('type')
        front_content = card_info.get('front', '')
        back_content = card_info.get('back', '')
        extra_content = card_info.get('extra', '')
        vignette_content = card_info.get('vignette', '')
        mnemonic_content = card_info.get('mnemonic', '')
        image_ref = card_info.get('image_ref', '')
        tags = card_info.get('tags',)

        # Convert [CLOZE::text] to {{c#::text}} for cloze cards
        if card_type == 'cloze':
            front_content = convert_cloze_placeholder(front_content)
            # For cloze cards, the 'back' field might also contain cloze markers
            # if it's meant to reveal parts of the answer.
            back_content = convert_cloze_placeholder(back_content)

        # Handle image embedding
        # The image is directly referenced in the HTML template using {{Image}} field
        # so we just need to ensure the file is in media_files
        if image_ref:
            # Assuming images are in a 'media' folder
            image_path = os.path.join('media', image_ref)
            if os.path.exists(image_path):
                media_files.append(image_path)
            else:
                print(f"Warning: Image file not found at {image_path}. Skipping image for this card.")

        # Create the note fields, ensuring all expected fields are present
        fields_data = [
            front_content,
            back_content,
            extra_content,
            vignette_content,
            mnemonic_content,
            image_ref # Pass the image_ref directly to the Image field
        ]

        # Determine which model template to use
        # genanki.Note automatically selects the correct card template based on the model's templates list
        # and whether the 'cloze' field is used in the qfmt/afmt.
        note = genanki.Note(
            model=my_model,
            fields=fields_data,
            tags=tags # genanki handles tags directly
        )
        
        my_deck.add_note(note)

    # Create the Anki package
    my_package = genanki.Package(my_deck)
    my_package.media_files = media_files

    # Write the package to a file
    my_package.write_to_file(output_filename)
    print(f"Anki deck '{output_filename}' created successfully!")
    print(f"Total media files included: {len(my_package.media_files)}")


# --- 6. Example Usage (Simulated Agent Output) ---
# This simulates the *final* output from your n8n Function Node's 'cards' array.
# In a real n8n workflow, you would pass the 'cards' array from the Function Node
# directly to the Python script (e.g., via a webhook or file transfer).
SIMULATED_N8N_FUNCTION_NODE_OUTPUT = [
  {
    "type": "cloze",
    "front": "Pain signals come into the cord from [CLOZE::small diameter primary afferents] and diverge into a spinal level above and below in a pathway called Lissauer's tract.",
    "back": "",
    "tags":,
    "extra": "Lissauer's tract allows pain signals to ascend or descend 1-2 spinal segments before synapsing.",
    "mnemonic": "Lissauerâ€™s Lever: 'Lever Up/Down 1-2' for Lissauer's tract ascending or descending 1-2 spinal segments."
  },
  {
    "type": "cloze",
    "front": "Second order neurons of the spinothalamic tract synapse at the ipsilateral dorsal horn in the [CLOZE::substantia gelatinosa] or [CLOZE::nucleus proprius].",
    "back": "",
    "tags":,
    "extra": "These regions process pain and temperature sensory input.",
    "vignette": "A 45-year-old man presents with intense, burning pain in his right leg after a motorcycle accident. Physical exam reveals decreased pain sensation on the affected leg. MRI shows damage localized to the ipsilateral dorsal horn region of the spinal cord. Which spinal regions are mostly likely affected for the sensation of pain and temperature?\\n\\nA. Nucleus dorsalis\\nB. <b><span class=\\\"highlight-red\\\">SUBSTANTIA GELATINOSA OR NUCLEUS PROPRIUS</span></b>\\nC. Ventral posterolateral nucleus\\nD. Lateral spinothalamic tract\\nD. Spinal lemniscus\\nE. Anterior white commissure\\n\\nCorrect Answer: B. <b><span class=\\\"highlight-red\\\">SUBSTANTIA GELATINOSA OR NUCLEUS PROPRIUS</span></b>\\nExplanation: Second order neurons crucial for processing pain and temperature sensibility synapse in these regions, particularly after injury or dysfunction.",
    "mnemonic": "Second Syn: 'Second Snaps In Gelato' for second order synapsing in substantia gelatinosa."
  },
  {
    "type": "basic",
    "front": "Where do second order neurons of the spinothalamic tract decussate?",
    "back": "At the <b><span class=\\\"highlight-red\\\">ANTERIOR WHITE COMMISSURE</span></b> of the spinal cord.",
    "tags":,
    "extra": "Decussation occurs anteriorly near the spinal segment of entry.",
    "vignette": "A 53-year-old female with chronic lower back pain undergoes a spinal surgery. Postoperatively, she exhibits unusual sensations across her body. Given the location of decussation of the pain-pathway fibers, where is the most plausible site of surgical impact?\\n\\nA. Posterior white commissure\\nB. Lateral spinothalamic tract\\nC. <b><span class=\\\"highlight-red\\\">ANTERIOR WHITE COMMISSURE</span></b>\\nD. Spinal lemniscus\\nE. Medial longitudinal fasciculus\\n\\nCorrect Answer: C. <b><span class=\\\"highlight-red\\\">ANTERIOR WHITE COMMISSURE</span></b>\\nExplanation: The second order neurons of the spinothalamic tract cross here, which could be implicated in abnormal sensory symptoms post-surgery."
  },
  {
    "type": "basic",
    "front": "In the contralateral spinothalamic tract, which body region's sensory fibers lie more lateral and which lie more medial?",
    "back": "<b><span class=\\\"highlight-red\\\">LEG</span></b> fibers are more <b><span class=\\\"highlight-red\\\">LATERAL</span></b>, and <b><span class=\\\"highlight-red\\\">ARM</span></b> fibers are more <b><span class=\\\"highlight-red\\\">MEDIAL</span></b>, opposite to the dorsal column-medial lemniscus system.",
    "tags":,
    "extra": "This organization is reversed compared to the dorsal column-medial lemniscus pathway.",
    "mnemonic": "LA Med: 'Legs Are Lateral, Medial Arm' to remember the organization in the spinothalamic tract."
  }
]

if __name__ == "__main__":
    # Ensure the 'media' directory exists
    if not os.path.exists('media'):
        os.makedirs('media')
        print("Created 'media' directory. Please place your image files here.")

    # Create dummy image files for testing if they don't exist
    # In a real scenario, these would be uploaded by the user
    dummy_images = ["Image 1.png", "Image 2.png", "_AnKingIcon.png"]
    for img_name in dummy_images:
        img_path = os.path.join('media', img_name)
        if not os.path.exists(img_path):
            try:
                from PIL import Image
                # Create a simple dummy image
                img = Image.new('RGB', (60, 30), color = 'red')
                img.save(img_path)
                print(f"Created dummy image: {img_path}")
            except ImportError:
                print(f"Pillow not installed. Cannot create dummy image {img_path}. Please install `pip install Pillow` or provide actual image files.")
                # Create an empty file as a placeholder if Pillow is not available
                with open(img_path, 'w') as f:
                    f.write("") # Empty file, will likely cause Anki error but allows script to run

    # In a real n8n workflow, you would receive the JSON data from the Function Node
    # For local testing, we use the SIMULATED_N8N_FUNCTION_NODE_OUTPUT
    
    # If you were receiving the full n8n output (e.g., from a webhook body),
    # it might look like:
    # received_data = json.loads(sys.stdin.read()) # or from a Flask request.json
    # cards_to_process = received_data['json']['cards'] # Access the 'cards' array
    
    # For this script, we directly use the simulated final array:
    create_anki_deck(SIMULATED_N8N_FUNCTION_NODE_OUTPUT)