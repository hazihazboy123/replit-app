import os
import json
import tempfile
import logging
import random
import uuid
import time
import html
import re
import requests
import hashlib
from urllib.parse import urlparse
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from flask import Flask, render_template, request, flash, send_file, redirect, url_for, jsonify
from flask_cors import CORS
import genanki

# Configure logging
logging.basicConfig(level=logging.DEBUG)

# Create the app
app = Flask(__name__)
app.secret_key = os.environ.get("SESSION_SECRET", "dev-secret-key-change-in-production")

# Configure CORS for API endpoints
CORS(app, resources={
    r"/api/*": {
        "origins": "*",
        "methods": ["GET", "POST", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"]
    }
})

class RobustImageDownloader:
    """Production-grade image downloader with comprehensive error handling"""
    
    def __init__(self, timeout=(15, 45), chunk_size=8192, max_retries=3):
        self.timeout = timeout
        self.chunk_size = chunk_size
        self.session = self._create_session(max_retries)
        
    def _create_session(self, max_retries):
        """Create session with advanced retry strategy"""
        session = requests.Session()
        
        retry_strategy = Retry(
            total=max_retries,
            status_forcelist=[429, 500, 502, 503, 504, 520, 522, 524],
            backoff_factor=0.5,
            allowed_methods=["HEAD", "GET"],
            respect_retry_after_header=True
        )
        
        adapter = HTTPAdapter(
            max_retries=retry_strategy,
            pool_connections=20,
            pool_maxsize=20,
            pool_block=False
        )
        
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        # Enhanced headers for better compatibility
        session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Sec-Fetch-Dest': 'image',
            'Sec-Fetch-Mode': 'no-cors',
            'Sec-Fetch-Site': 'cross-site',
            'Cache-Control': 'no-cache'
        })
        
        return session
    
    def download_image(self, url, media_files_list):
        """Download image with comprehensive error handling and validation"""
        try:
            app.logger.info(f"üîÑ Downloading image from: {url}")
            
            # Generate safe filename
            parsed_url = urlparse(url)
            filename = os.path.basename(parsed_url.path)
            
            if not filename or '.' not in filename or len(filename) < 4:
                url_hash = hashlib.md5(url.encode()).hexdigest()[:12]
                filename = f"medical_image_{url_hash}.jpg"
            
            # Ensure valid extension
            valid_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp']
            if not any(filename.lower().endswith(ext) for ext in valid_extensions):
                filename += '.jpg'
            
            app.logger.info(f"üìÅ Generated filename: {filename}")
            
            # Make request with streaming
            response = self.session.get(url, timeout=self.timeout, stream=True, allow_redirects=True)
            response.raise_for_status()
            
            # Validate content type
            content_type = response.headers.get('content-type', '').lower()
            app.logger.info(f"üìã Content-Type: {content_type}")
            
            if not any(img_type in content_type for img_type in ['image/', 'jpeg', 'png', 'gif', 'webp']):
                app.logger.warning(f"‚ö†Ô∏è Suspicious content type: {content_type}")
                # Continue anyway as some servers don't set proper content-type
            
            # Save to temporary file
            temp_path = os.path.join(tempfile.gettempdir(), filename)
            app.logger.info(f"üíæ Saving to: {temp_path}")
            
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            
            with open(temp_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=self.chunk_size):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
            
            # Verify file was created and has content
            if os.path.exists(temp_path) and os.path.getsize(temp_path) > 0:
                file_size = os.path.getsize(temp_path)
                media_files_list.append(temp_path)
                app.logger.info(f"üéâ Successfully downloaded: {filename} ({file_size} bytes)")
                return filename
            else:
                app.logger.error(f"‚ùå File not created or empty: {temp_path}")
                return None
                
        except requests.exceptions.Timeout:
            app.logger.error(f"‚è∞ Timeout downloading image from {url}")
            return None
        except requests.exceptions.RequestException as e:
            app.logger.error(f"üåê Request error downloading image from {url}: {e}")
            return None
        except Exception as e:
            app.logger.error(f"üí• Unexpected error downloading image from {url}: {e}")
            return None

def clean_text_content(text):
    """Clean text content to remove formatting artifacts and extra braces"""
    if not text:
        return text
    
    # Convert to string and clean aggressively
    text = str(text)
    
    # Remove extra braces (but preserve intentional ones like {{c1::text}})
    # First preserve Anki cloze syntax
    cloze_pattern = r'(\{\{c\d+::[^}]+\}\})'
    clozes = re.findall(cloze_pattern, text)
    
    # Temporarily replace clozes with placeholders
    for i, cloze in enumerate(clozes):
        text = text.replace(cloze, f"__CLOZE_PLACEHOLDER_{i}__")
    
    # Now remove extra standalone braces
    text = re.sub(r'\s*\}\s*$', '', text)  # Remove trailing braces
    text = re.sub(r'^\s*\{\s*', '', text)  # Remove leading braces
    text = re.sub(r'\s*\}\s*\}\s*', '}', text)  # Remove double closing braces
    
    # Restore clozes
    for i, cloze in enumerate(clozes):
        text = text.replace(f"__CLOZE_PLACEHOLDER_{i}__", cloze)
    
    # Clean up whitespace
    text = re.sub(r'\s+', ' ', text).strip()
    text = text.replace('\\n', ' ').replace('\n', ' ')
    
    return text

def apply_medical_highlighting(text):
    """Apply evidence-based highlighting to medical terms"""
    if not text:
        return text
    
    # Medical terms for highlighting - expanded list
    medical_terms = [
        # Anatomical terms
        r'\b(cervical enlargement|lumbosacral enlargement|lumbo?sacral enlargement)\b',
        r'\b(brachial plexus|lumbosacral plexus|lumbo?sacral plexus)\b',
        r'\b(spinal cord|spinal nerves?|vertebral levels?)\b',
        r'\b(dorsal horn|substantia gelatinosa|spinothalamic tract)\b',
        
        # Spinal levels
        r'\b([CLT]\d+-[CLT]\d+)\b',
        r'\b([CLT]\d+)\b',
        r'\b(L1-L2|L2-L3|L3-L4|L2-S3|L5-S1|C4-T1|T1-T12)\b',
        
        # Clinical terms
        r'\b(weakness|sensation|abduction|flexion|extension|reflexes)\b',
        r'\b(neurological examination|neurological assessment|imaging|injury|MRI)\b',
        r'\b(epidural|anesthesia|analgesia|lower limb|upper limb)\b',
        r'\b(diminished reflexes|lower limb weakness|difficulty walking)\b',
        r'\b(presents with|assessment reveals|crucial for)\b',
    ]
    
    highlighted_text = text
    for pattern in medical_terms:
        highlighted_text = re.sub(
            pattern, 
            r'<span class="medical-highlight">\1</span>', 
            highlighted_text, 
            flags=re.IGNORECASE
        )
    
    return highlighted_text

def format_clinical_vignette(vignette_data):
    """Format clinical vignette with professional blue styling and click-to-reveal"""
    if not vignette_data:
        return ''
    
    # Handle both dict and string formats
    if isinstance(vignette_data, dict):
        clinical_case = vignette_data.get('clinical_case', '')
        explanation = vignette_data.get('explanation', '')
        combined_content = f"{clinical_case} {explanation}".strip()
    else:
        combined_content = str(vignette_data).strip()
    
    if not combined_content:
        return ''
    
    # Clean the content thoroughly
    combined_content = clean_text_content(combined_content)
    
    app.logger.info(f"Processing vignette: {combined_content[:100]}...")
    
    # Parse content sections
    question_part = ""
    choices_part = ""
    answer_part = ""
    
    if 'Answer Choices:' in combined_content and 'Correct Answer:' in combined_content:
        parts = combined_content.split('Answer Choices:', 1)
        question_part = parts[0].strip()
        
        if len(parts) > 1:
            choices_and_answer = parts[1]
            if 'Correct Answer:' in choices_and_answer:
                choice_parts = choices_and_answer.split('Correct Answer:', 1)
                choices_part = choice_parts[0].strip()
                answer_part = choice_parts[1].strip() if len(choice_parts) > 1 else ""
            else:
                choices_part = choices_and_answer.strip()
    else:
        question_part = combined_content
    
    # Build formatted content with medical blue theme
    formatted_content = f'<div class="clinical-case-text">{question_part}</div>'
    
    if choices_part:
        formatted_content += '<div class="answer-choices"><strong>Answer Choices:</strong><br>'
        # Format choices on separate lines
        choice_lines = re.findall(r'[A-F]\.[^A-F]*?(?=[A-F]\.|$)', choices_part)
        for choice in choice_lines:
            choice = choice.strip()
            if choice:
                formatted_content += f'{choice}<br>'
        formatted_content += '</div>'
    
    if answer_part:
        # Create professional click-to-reveal section
        formatted_content += f'''
        <div class="answer-reveal-section">
            <div class="reveal-button">
                üîç Click to reveal correct answer and explanation ‚Üì
            </div>
            <div class="hidden-answer">
                <div class="correct-answer-header">Correct Answer:</div>
                <div class="correct-answer-text">{answer_part}</div>
                <div class="explanation-header">Clinical Explanation:</div>
                <div class="explanation-text">This answer demonstrates the key clinical concept being tested in this medical scenario.</div>
            </div>
        </div>'''
    
    return formatted_content

def create_enhanced_medical_model():
    """Create enhanced AnKing-style model with professional medical styling"""
    
    # Evidence-based CSS for medical education
    medical_css = """
/* Enhanced Medical Flashcard Styling - Evidence-Based Design */

/* Base typography optimized for medical learning */
html {
    font-size: 18px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.mobile {
    font-size: 18px;
}

.card {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    font-size: 1rem;
    line-height: 1.6;
    color: #2c3e50;
    background-color: #ffffff;
    text-align: center;
    margin: 0px 15px;
    padding: 20px;
    max-width: 800px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.mobile.card {
    padding: 15px;
    margin: 10px;
}

/* Answer separator */
hr {
    border: none;
    border-top: 2px solid #3498db;
    margin: 20px 0;
    opacity: 0.7;
}

/* Medical term highlighting */
.medical-highlight {
    color: #e74c3c;
    font-weight: 600;
    background-color: rgba(231, 76, 60, 0.1);
    padding: 2px 4px;
    border-radius: 3px;
}

/* CLINICAL VIGNETTE STYLING - Professional Medical Blue */
#vignette-section {
    background: linear-gradient(135deg, #ebf4ff 0%, #dbeafe 100%);
    border: 3px solid #3b82f6;
    border-radius: 12px;
    padding: 24px;
    margin: 20px 0;
    text-align: left;
    box-shadow: 0 6px 20px rgba(59, 130, 246, 0.15);
}

#vignette-section h3 {
    color: #1e40af;
    margin-top: 0;
    margin-bottom: 16px;
    font-size: 1.3em;
    font-weight: bold;
    text-align: center;
    background: linear-gradient(135deg, #ffffff 0%, #f0f9ff 100%);
    padding: 12px;
    border-radius: 8px;
    border: 2px solid #3b82f6;
}

.vignette-content {
    line-height: 1.7;
    color: #1e3a8a;
    font-size: 1em;
    font-weight: 500;
}

/* Clinical vignette components */
.clinical-case-text {
    color: #1e40af;
    line-height: 1.7;
    margin-bottom: 16px;
    font-weight: 500;
}

.answer-choices {
    background-color: #f8fafc;
    padding: 16px;
    border-radius: 8px;
    border-left: 4px solid #60a5fa;
    margin: 16px 0;
    color: #1e40af;
}

.answer-choices strong {
    color: #1d4ed8;
    font-size: 1.1em;
}

/* Click-to-reveal answer section */
.answer-reveal-section {
    background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
    border: 2px solid #0ea5e9;
    border-radius: 10px;
    margin: 20px 0;
    padding: 0;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(14, 165, 233, 0.2);
    transition: all 0.3s ease;
}

.answer-reveal-section:hover {
    background: linear-gradient(135deg, #e0f2fe 0%, #bae6fd 100%);
    border-color: #0284c7;
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(14, 165, 233, 0.3);
}

.reveal-button {
    color: #0369a1;
    font-weight: bold;
    font-size: 1.1em;
    text-align: center;
    padding: 16px;
    border-radius: 8px;
}

.hidden-answer {
    display: none;
    padding: 20px;
    border-top: 2px solid #0ea5e9;
    animation: fadeIn 0.3s ease-in-out;
}

.correct-answer-header {
    color: #0c4a6e;
    font-weight: bold;
    font-size: 1.1em;
    margin-bottom: 10px;
}

.correct-answer-text {
    color: #dc2626;
    font-weight: bold;
    margin-bottom: 20px;
    font-size: 1.05em;
    background-color: #fef2f2;
    padding: 10px;
    border-radius: 6px;
    border-left: 4px solid #dc2626;
}

.explanation-header {
    color: #0c4a6e;
    font-weight: bold;
    margin-bottom: 10px;
}

.explanation-text {
    color: #1e40af;
    line-height: 1.6;
    font-style: italic;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* MNEMONIC STYLING - Complementary Green */
#mnemonic-section {
    background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
    border: 3px solid #22c55e;
    border-radius: 12px;
    padding: 24px;
    margin: 20px 0;
    text-align: left;
    box-shadow: 0 6px 20px rgba(34, 197, 94, 0.15);
}

#mnemonic-section h3 {
    color: #15803d;
    margin-top: 0;
    margin-bottom: 16px;
    font-size: 1.3em;
    font-weight: bold;
    text-align: center;
    background: linear-gradient(135deg, #ffffff 0%, #f0fdf4 100%);
    padding: 12px;
    border-radius: 8px;
    border: 2px solid #22c55e;
}

.mnemonic-content {
    font-weight: bold;
    color: #166534;
    line-height: 1.6;
    font-size: 1.1em;
}

/* IMAGE STYLING */
.image-container {
    text-align: center;
    margin: 20px 0;
    padding: 15px;
    background-color: #f8fafc;
    border-radius: 8px;
    border: 2px solid #e2e8f0;
}

.image-container img {
    max-width: 90%;
    height: auto;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border: 2px solid #cbd5e1;
}

.image-caption {
    text-align: center;
    font-style: italic;
    margin-top: 12px;
    color: #64748b;
    font-size: 0.9em;
    line-height: 1.4;
}

/* EXTRA NOTES STYLING */
#extra {
    font-style: italic;
    font-size: 0.95rem;
    color: #4338ca;
    margin-top: 25px;
    padding: 15px;
    background-color: #faf5ff;
    border-left: 4px solid #8b5cf6;
    border-radius: 6px;
    text-align: left;
}

/* NIGHT MODE SUPPORT */
.nightMode.card,
.night_mode.card {
    color: #e2e8f0 !important;
    background-color: #1a202c !important;
}

.nightMode #vignette-section, .night_mode #vignette-section {
    background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);
    border-color: #60a5fa;
}

.nightMode #vignette-section h3, .night_mode #vignette-section h3 {
    color: #bfdbfe;
    background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
    border-color: #60a5fa;
}

.nightMode .vignette-content, .night_mode .vignette-content {
    color: #dbeafe;
}

.nightMode #mnemonic-section, .night_mode #mnemonic-section {
    background: linear-gradient(135deg, #14532d 0%, #166534 100%);
    border-color: #4ade80;
}

.nightMode #mnemonic-section h3, .night_mode #mnemonic-section h3 {
    color: #bbf7d0;
    background: linear-gradient(135deg, #166534 0%, #14532d 100%);
    border-color: #4ade80;
}

.nightMode .mnemonic-content, .night_mode .mnemonic-content {
    color: #86efac;
}

.nightMode .medical-highlight, .night_mode .medical-highlight {
    color: #fca5a5 !important;
    background-color: rgba(252, 165, 165, 0.2);
}

/* JavaScript for click-to-reveal functionality */
.card script, script {
    display: none;
}
"""
    
    # JavaScript for interactive functionality
    interactive_js = """
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Add click functionality to answer reveal sections
    const revealSections = document.querySelectorAll('.answer-reveal-section');
    
    revealSections.forEach(function(section) {
        section.addEventListener('click', function() {
            const hiddenAnswer = this.querySelector('.hidden-answer');
            if (hiddenAnswer) {
                if (hiddenAnswer.style.display === 'none' || hiddenAnswer.style.display === '') {
                    hiddenAnswer.style.display = 'block';
                } else {
                    hiddenAnswer.style.display = 'none';
                }
            }
        });
    });
});
</script>"""
    
    # Define fields
    fields = [
        {'name': 'Front'},
        {'name': 'Back'}, 
        {'name': 'Extra'},
        {'name': 'Vignette'},
        {'name': 'Mnemonic'},
        {'name': 'Image'}
    ]

    # Templates with proper conditional logic to prevent duplication
    templates = [
        {
            'name': 'Enhanced Medical Card',
            'qfmt': '''
                <div class="medical-card-front">
                    <div class="question-content">{{Front}}</div>
                </div>
            ''' + interactive_js,
            'afmt': '''
                {{FrontSide}}
                <hr class="answer-divider">
                
                {{#Back}}
                <div class="answer-content">{{Back}}</div>
                {{/Back}}

                {{#Vignette}}
                <div id="vignette-section">
                    <h3>ü©∫ Clinical Vignette</h3>
                    <div class="vignette-content">{{{Vignette}}}</div>
                </div>
                {{/Vignette}}

                {{#Mnemonic}}
                <div id="mnemonic-section">
                    <h3>üß† Memory Aid</h3>
                    <div class="mnemonic-content">{{{Mnemonic}}}</div>
                </div>
                {{/Mnemonic}}

                {{#Image}}
                <div class="image-container">
                    {{{Image}}}
                </div>
                {{/Image}}

                {{#Extra}}
                <div id="extra">{{{Extra}}}</div>
                {{/Extra}}
            ''',
        }
    ]

    # Create the model
    model = genanki.Model(
        1607392321,  # Unique ID for enhanced version
        'Enhanced Medical Cards V2',
        fields=fields,
        templates=templates,
        css=medical_css
    )
    
    return model

class EnhancedMedicalProcessor:
    """Enhanced processor for medical flashcards with comprehensive error handling"""
    
    def __init__(self):
        self.model = create_enhanced_medical_model()
        self.image_downloader = RobustImageDownloader()
    
    def process_cards(self, cards_data, deck_name="Enhanced Medical Deck"):
        """Process cards with enhanced medical formatting and error handling"""
        
        # Generate unique deck ID to prevent merging
        deck_id = random.randrange(1 << 30, 1 << 31)
        deck = genanki.Deck(deck_id, deck_name)
        media_files = []
        
        for card_info in cards_data:
            try:
                # Extract and clean basic fields
                front_content = clean_text_content(card_info.get('front', ''))
                back_content = clean_text_content(card_info.get('back', ''))
                extra_content = clean_text_content(card_info.get('extra', ''))
                
                # Apply medical highlighting
                if front_content:
                    front_content = apply_medical_highlighting(front_content)
                if back_content:
                    back_content = apply_medical_highlighting(back_content)
                if extra_content:
                    extra_content = apply_medical_highlighting(extra_content)
                
                # Process clinical vignette with blue styling
                vignette_content = format_clinical_vignette(card_info.get('vignette', ''))
                
                # Process mnemonic with highlighting
                mnemonic_data = card_info.get('mnemonic', '')
                mnemonic_content = ''
                if mnemonic_data:
                    mnemonic_content = apply_medical_highlighting(clean_text_content(mnemonic_data))
                
                # Handle image download and embedding - FIXED TO APPEAR ONLY ONCE
                image_content = ''
                image_data = card_info.get('image', '')
                if image_data:
                    app.logger.info(f"Processing image for card: {front_content[:50]}...")
                    
                    if isinstance(image_data, dict):
                        url = image_data.get('url', '')
                        caption = clean_text_content(image_data.get('caption', ''))
                        
                        if url:
                            app.logger.info(f"Downloading image from URL: {url}")
                            downloaded_filename = self.image_downloader.download_image(url, media_files)
                            
                            if downloaded_filename:
                                app.logger.info(f"‚úÖ Successfully downloaded: {downloaded_filename}")
                                # Create properly formatted image HTML - SINGLE INSTANCE
                                image_content = f'<img src="{downloaded_filename}" alt="{caption}" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">'
                                if caption:
                                    image_content += f'<div class="image-caption">{caption}</div>'
                            else:
                                app.logger.warning(f"‚ùå Failed to download image from: {url}")
                                # Create informative placeholder instead of error message
                                image_content = f'<div style="text-align: center; padding: 20px; background-color: #f8f9fa; border: 2px dashed #6c757d; border-radius: 8px; color: #6c757d;">Medical Image Reference: {url[:50]}...</div>'
                        
                    elif isinstance(image_data, str) and image_data.strip():
                        if image_data.startswith('http'):
                            downloaded_filename = self.image_downloader.download_image(image_data, media_files)
                            if downloaded_filename:
                                image_content = f'<img src="{downloaded_filename}" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">'
                            else:
                                image_content = f'<div style="text-align: center; padding: 20px; background-color: #f8f9fa; border: 2px dashed #6c757d; border-radius: 8px; color: #6c757d;">Medical Image Reference: {image_data[:50]}...</div>'
                        else:
                            # Local filename
                            image_content = f'<img src="{image_data}" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">'
                
                # Create the note with cleaned content
                note = genanki.Note(
                    model=self.model,
                    fields=[
                        front_content,      # Front
                        back_content,       # Back
                        extra_content,      # Extra
                        vignette_content,   # Vignette
                        mnemonic_content,   # Mnemonic
                        image_content       # Image - APPEARS ONLY HERE
                    ],
                    tags=[clean_text_content(str(tag)).replace(' ', '_') for tag in card_info.get('tags', [])]
                )
                
                deck.add_note(note)
                
            except Exception as e:
                app.logger.error(f"Error processing card: {e}")
                # Continue with next card instead of failing entirely
                continue
        
        return deck, media_files

def generate_synaptic_recall_name(cards):
    """Generate intelligent deck name based on medical content analysis"""
    all_text = []
    for card in cards:
        front_text = str(car