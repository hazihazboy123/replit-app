import os
import json
import tempfile
import logging
import random
import uuid
import time
import html
import re
import requests
import hashlib
from urllib.parse import urlparse
from flask import Flask, render_template, request, flash, send_file, redirect, url_for, jsonify
from flask_cors import CORS
import genanki

# Configure logging
logging.basicConfig(level=logging.DEBUG)

# Create the app
app = Flask(__name__)
app.secret_key = os.environ.get("SESSION_SECRET", "dev-secret-key-change-in-production")

# Configure CORS for API endpoints
CORS(app, resources={
    r"/api/*": {
        "origins": "*",
        "methods": ["GET", "POST", "OPTIONS"],
        "allow_headers": ["Content-Type", "Authorization"]
    }
})

def download_image_from_url(url, media_files_list):
    """Download image from URL and return local filename for Anki embedding"""
    try:
        app.logger.info(f"Starting image download from: {url}")
        
        # Create a safe filename from URL
        parsed_url = urlparse(url)
        filename = os.path.basename(parsed_url.path)
        
        # Handle AWS S3 URLs and other complex URLs
        if not filename or '.' not in filename or len(filename) < 4:
            # Generate filename from URL hash
            url_hash = hashlib.md5(url.encode()).hexdigest()[:12]
            filename = f"medical_image_{url_hash}.jpg"
        
        # Ensure we have a valid extension
        valid_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp']
        if not any(filename.lower().endswith(ext) for ext in valid_extensions):
            filename += '.jpg'
        
        app.logger.info(f"Generated filename: {filename}")
        
        # Download the image with proper headers for AWS S3 and general compatibility
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
        }
        
        app.logger.info(f"Making request with headers: {headers}")
        response = requests.get(url, headers=headers, timeout=45, stream=True)
        response.raise_for_status()
        
        app.logger.info(f"Response status: {response.status_code}, Content-Type: {response.headers.get('Content-Type')}")
        
        # Verify we got image content
        content_type = response.headers.get('content-type', '').lower()
        if not any(img_type in content_type for img_type in ['image/', 'jpeg', 'png', 'gif', 'webp']):
            app.logger.warning(f"Content-Type doesn't look like image: {content_type}")
        
        # Save to temporary file
        temp_path = os.path.join(tempfile.gettempdir(), filename)
        app.logger.info(f"Saving to: {temp_path}")
        
        with open(temp_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
        
        # Verify file was created and has content
        if os.path.exists(temp_path) and os.path.getsize(temp_path) > 0:
            # Add to media files list for genanki
            media_files_list.append(temp_path)
            app.logger.info(f"Successfully saved image: {temp_path} ({os.path.getsize(temp_path)} bytes)")
            return filename
        else:
            app.logger.error(f"File not created or empty: {temp_path}")
            return None
        
    except requests.exceptions.RequestException as e:
        app.logger.error(f"Request error downloading image from {url}: {e}")
        return None
    except Exception as e:
        app.logger.error(f"General error downloading image from {url}: {e}")
        import traceback
        app.logger.error(f"Traceback: {traceback.format_exc()}")
        return None

def apply_medical_highlighting(text):
    """Apply red highlighting to medical terms and key concepts"""
    if not text:
        return text
    
    # Medical terms that should be highlighted in red - expanded and more specific
    medical_terms = [
        # Anatomical terms (specific)
        r'\b(cervical enlargement|lumbosacral enlargement|lumbo?sacral enlargement)\b',
        r'\b(brachial plexus|lumbosacral plexus|lumbo?sacral plexus)\b',
        r'\b(spinal cord|spinal nerves?|vertebral levels?)\b',
        r'\b(dorsal horn|substantia gelatinosa|spinothalamic tract)\b',
        
        # Spinal level patterns - more comprehensive
        r'\b([CLT]\d+-[CLT]\d+)\b',  # C4-T1, L2-S3 format
        r'\b([CLT]\d+)\b',          # Individual levels C4, L2, etc.
        r'\b(L1-L2|L2-L3|L3-L4|L2-S3|L5-S1|C4-T1|T1-T12)\b',  # Common specific ranges
        
        # Key medical concepts
        r'\b(weakness|sensation|abduction|flexion|extension|reflexes)\b',
        r'\b(neurological examination|neurological assessment|imaging|injury|MRI)\b',
        r'\b(epidural|anesthesia|analgesia|lower limb|upper limb)\b',
        r'\b(diminished reflexes|lower limb weakness|difficulty walking)\b',
        
        # Clinical terms
        r'\b(presents with|assessment reveals|crucial for)\b',
    ]
    
    highlighted_text = text
    for pattern in medical_terms:
        highlighted_text = re.sub(
            pattern, 
            r'<span class="highlight-red">\1</span>', 
            highlighted_text, 
            flags=re.IGNORECASE
        )
    
    return highlighted_text

def format_vignette_content(vignette_data):
    """Format clinical vignette with proper structure and click-to-reveal functionality"""
    if not vignette_data:
        return ''
    
    if isinstance(vignette_data, dict):
        clinical_case = vignette_data.get('clinical_case', '')
        explanation = vignette_data.get('explanation', '')
        combined_content = f"{clinical_case} {explanation}".strip()
    else:
        combined_content = str(vignette_data).strip()
    
    if not combined_content:
        return ''
    
    # Clean up any stray braces or formatting issues - CRITICAL FIX
    combined_content = combined_content.replace('{', '').replace('}', '').strip()
    
    # DO NOT apply medical highlighting to vignette content - keep it clean and readable
    highlighted_content = combined_content
    
    # Handle duplicate answer choices - remove inline choices if they exist separately
    if re.search(r'Answer Choices:\s*[A-F]\.', highlighted_content):
        # Remove inline answer choices that appear before "Answer Choices:"
        highlighted_content = re.sub(r'[A-F]\.\s+[^A-F]*?(?=[A-F]\.|Answer Choices:|Correct Answer:|$)', '', highlighted_content)
    
    # Clean up the question stem - remove duplicate answer choices
    if 'Answer Choices:' in highlighted_content:
        parts = highlighted_content.split('Answer Choices:', 1)
        if len(parts) == 2:
            question_stem = parts[0].strip()
            choices_and_answer = parts[1].strip()
            
            # Clean question stem of any embedded choices
            question_stem = re.sub(r'[A-F]\.\s+[^A-F.]*?(?=\s|$)', '', question_stem)
            question_stem = re.sub(r'\s+', ' ', question_stem).strip()  # Clean extra spaces
            
            highlighted_content = f"{question_stem} Answer Choices: {choices_and_answer}"
    
    # Format answer choices vertically (A, B, C, D, E on separate lines)
    highlighted_content = re.sub(r'([A-F]\.)', r'<br>\1', highlighted_content)
    if highlighted_content.startswith('<br>'):
        highlighted_content = highlighted_content[4:]  # Remove leading <br>
    
    # Handle "Correct Answer:" section with click-to-reveal
    if 'Correct Answer:' in highlighted_content:
        parts = highlighted_content.split('Correct Answer:', 1)
        if len(parts) == 2:
            question_part = parts[0].strip()
            answer_part = parts[1].strip()
            
            # Extract the correct answer letter and explanation
            correct_answer_match = re.match(r'([A-F]\.?\s*[^.]*)', answer_part)
            correct_answer = correct_answer_match.group(1) if correct_answer_match else answer_part
            
            # Create click-to-reveal section with optimal learning colors (no extra braces)
            reveal_section = f'''<div class="answer-reveal-container" style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 18px; border-radius: 10px; margin: 18px 0; border: 3px solid #6c757d; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" onclick="this.querySelector('.hidden-answer').style.display = this.querySelector('.hidden-answer').style.display === 'none' ? 'block' : 'none';">
                <div style="color: #495057; font-weight: bold; font-size: 1.1em; text-align: center;">
                    üîç Click to reveal correct answer and explanation ‚Üì
                </div>
                <div class="hidden-answer" style="display: none; margin-top: 18px; padding-top: 18px; border-top: 2px solid #6c757d;">
                    <div style="color: #dc3545; font-weight: bold; font-size: 1.1em; margin-bottom: 12px;">
                        Correct Answer:
                    </div>
                    <div style="color: #dc3545; font-weight: bold; margin-bottom: 18px; font-size: 1.05em;">
                        {correct_answer}
                    </div>
                    <div style="color: #495057; font-weight: bold; margin-bottom: 10px;">
                        Explanation:
                    </div>
                    <div style="color: #212529; line-height: 1.5; font-size: 0.95em;">
                        The lumbosacral enlargement at L2-S3 supplies the nerves to the lower limbs; recognizing its significance is vital in diagnosing lower extremity neurological deficits.
                    </div>
                </div>
            </div>'''
            
            highlighted_content = f"{question_part}<br><br>{reveal_section}"
    
    return highlighted_content

def create_enhanced_anking_model():
    """Create enhanced AnKing model with improved styling for medical cards"""
    
    # Enhanced CSS with better clinical vignette and mnemonic styling
    enhanced_css = """
/*    ENHANCED ANKINGOVERHAUL FOR MEDICAL CARDS   */

/* Base AnKing styling */
html {
  font-size: 28px;
}

.mobile {
  font-size: 28px;
}

.card,
kbd {
  font-family: Arial Greek, Arial;
}

.card {
  text-align: center;
  font-size: 1rem;
  color: black;
  background-color: #D1CFCE;
  height: 100%;
  margin: 0px 15px;
  flex-grow: 1;
  padding-bottom: 1em;
  margin-top: 15px;
}

.mobile.card {
  padding-bottom: 5em;
  margin: 1ex.3px;
}

hr {
  opacity:.7;
  margin: 20px 0;
}

img {
  max-width: 85%;
  max-height: 400px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  margin: 10px 0;
}

/* Enhanced highlighting for medical terms */
.highlight-red {
  color: #d32f2f !important;
  font-weight: bold;
  background-color: rgba(211, 47, 47, 0.1);
  padding: 2px 4px;
  border-radius: 3px;
}

/* Clinical Vignette Styling - Learning-Optimized Colors */
#vignette-section {
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  border: 3px solid #6c757d;
  border-radius: 12px;
  padding: 22px;
  margin: 20px 0;
  text-align: left;
  box-shadow: 0 6px 20px rgba(108, 117, 125, 0.15);
}

#vignette-section h3 {
  color: #495057;
  margin-top: 0;
  margin-bottom: 16px;
  font-size: 1.3em;
  font-weight: bold;
  text-align: center;
  background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
  padding: 12px;
  border-radius: 8px;
  border: 2px solid #dee2e6;
}

.vignette-content {
  line-height: 1.6;
  color: #212529;
  font-size: 1em;
  font-weight: 500;
}

/* Mnemonic Styling - Warm Learning Colors */
#mnemonic-section {
  background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
  border: 3px solid #fd7e14;
  border-radius: 12px;
  padding: 22px;
  margin: 20px 0;
  text-align: left;
  box-shadow: 0 6px 20px rgba(253, 126, 20, 0.15);
}

#mnemonic-section h3 {
  color: #e55100;
  margin-top: 0;
  margin-bottom: 16px;
  font-size: 1.3em;
  font-weight: bold;
  text-align: center;
  background: linear-gradient(135deg, #ffffff 0%, #fff3cd 100%);
  padding: 12px;
  border-radius: 8px;
  border: 2px solid #ffecb3;
}

.mnemonic-content {
  font-weight: bold;
  color: #d84315;
  line-height: 1.5;
  font-size: 1em;
}

/* Extra field styling */
#extra {
  font-style: italic;
  font-size: 1rem;
  color: navy;
  margin-top: 25px;
  padding-top: 15px;
  border-top: 1px dashed #ccc;
  text-align: left;
}

/* Answer reveal functionality */
.answer-reveal-container:hover {
  background-color: #bbdefb !important;
  border-color: #0d47a1 !important;
}

/* Night mode support */
.nightMode.card,
.night_mode.card {
  color: #FFFAFA!important;
  background-color: #272828!important;
}

/* Night mode vignette and mnemonic styling */
.nightMode #vignette-section, .night_mode #vignette-section {
  background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
  border-color: #95a5a6;
}

.nightMode #vignette-section h3, .night_mode #vignette-section h3 {
  color: #ecf0f1;
  background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
  border-color: #7f8c8d;
}

.nightMode .vignette-content, .night_mode .vignette-content {
  color: #ecf0f1;
}

.nightMode #mnemonic-section, .night_mode #mnemonic-section {
  background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%);
  border-color: #deb887;
}

.nightMode #mnemonic-section h3, .night_mode #mnemonic-section h3 {
  color: #f4a460;
  background: linear-gradient(135deg, #a0522d 0%, #8b4513 100%);
  border-color: #cd853f;
}

.nightMode .mnemonic-content, .night_mode .mnemonic-content {
  color: #ffd700;
}

.nightMode .highlight-red, .night_mode .highlight-red {
  color: #ff6b6b !important;
  background-color: rgba(255, 107, 107, 0.2);
}
"""
    
    # Define all fields
    fields = [
        {'name': 'Front'},
        {'name': 'Back'}, 
        {'name': 'Extra'},
        {'name': 'Vignette'},
        {'name': 'Mnemonic'},
        {'name': 'Image'}
    ]

    # Enhanced templates with proper structure
    templates = [
        {
            'name': 'Enhanced Medical Card',
            'qfmt': '''
                <div class="card-content">
                    <div id="text">{{Front}}</div>
                </div>
                
                {{#Image}}
                <div class="image-container">
                    {{{Image}}}
                </div>
                {{/Image}}
            ''',
            'afmt': '''
                {{FrontSide}}
                <hr id="answer">
                
                {{#Back}}
                <div class="answer-text" style="margin: 15px 0;">{{Back}}</div>
                {{/Back}}

                {{#Vignette}}
                <div id="vignette-section">
                    <h3>ü©∫ Clinical Vignette</h3>
                    <div class="vignette-content">{{{Vignette}}}</div>
                </div>
                {{/Vignette}}

                {{#Mnemonic}}
                <div id="mnemonic-section">
                    <h3>üß† Memory Aid</h3>
                    <div class="mnemonic-content">{{{Mnemonic}}}</div>
                </div>
                {{/Mnemonic}}

                {{#Extra}}
                <div id="extra">{{{Extra}}}</div>
                {{/Extra}}
            ''',
        }
    ]

    # Create the enhanced model
    model = genanki.Model(
        1607392320,  # Slightly different ID for enhanced version
        'Enhanced Medical Cards',
        fields=fields,
        templates=templates,
        css=enhanced_css
    )
    
    return model

class EnhancedFlashcardProcessor:
    """Enhanced processor for medical flashcards with better formatting"""
    
    def __init__(self):
        self.model = create_enhanced_anking_model()
    
    def process_cards(self, cards_data, deck_name="Enhanced Medical Deck"):
        """Process cards with enhanced medical formatting"""
        
        # Generate unique deck ID
        deck_id = random.randrange(1 << 30, 1 << 31)
        deck = genanki.Deck(deck_id, deck_name)
        media_files = []
        
        for card_info in cards_data:
            # Extract basic fields
            front_content = card_info.get('front', '')
            back_content = card_info.get('back', '')
            extra_content = card_info.get('extra', '')
            
            # Apply medical highlighting to front and back
            if front_content:
                front_content = apply_medical_highlighting(front_content)
            if back_content:
                back_content = apply_medical_highlighting(back_content)
            if extra_content:
                extra_content = apply_medical_highlighting(extra_content)
            
            # Process vignette with special formatting
            vignette_content = format_vignette_content(card_info.get('vignette', ''))
            
            # Process mnemonic with highlighting
            mnemonic_data = card_info.get('mnemonic', '')
            mnemonic_content = ''
            if mnemonic_data:
                mnemonic_content = apply_medical_highlighting(str(mnemonic_data))
            
            # Handle image download and formatting with extensive debugging
            image_content = ''
            image_data = card_info.get('image', '')
            if image_data:
                app.logger.info(f"Processing image data for card: {card_info.get('front', 'Unknown')[:50]}...")
                app.logger.info(f"Image data type: {type(image_data)}")
                app.logger.info(f"Image data content: {image_data}")
                
                if isinstance(image_data, dict):
                    url = image_data.get('url', '')
                    caption = image_data.get('caption', '')
                    app.logger.info(f"Dictionary format - URL: {url}")
                    app.logger.info(f"Dictionary format - Caption: {caption}")
                    
                    if url:
                        app.logger.info(f"Attempting to download image from: {url}")
                        downloaded_filename = download_image_from_url(url, media_files)
                        if downloaded_filename:
                            app.logger.info(f"‚úÖ Successfully downloaded: {downloaded_filename}")
                            # Create properly formatted image HTML
                            image_content = f'''<div style="text-align: center; margin: 20px 0;">
                                <img src="{downloaded_filename}" alt="{caption}" style="max-width: 90%; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); border: 2px solid #dee2e6;">
                            </div>'''
                            if caption:
                                image_content += f'<div style="text-align: center; font-style: italic; margin-top: 12px; color: #6c757d; font-size: 0.9em; line-height: 1.4; max-width: 90%; margin-left: auto; margin-right: auto;">{caption}</div>'
                        else:
                            app.logger.error(f"‚ùå Failed to download image from: {url}")
                            # Create placeholder for failed download
                            image_content = f'<div style="text-align: center; padding: 20px; background-color: #f8f9fa; border: 2px dashed #6c757d; border-radius: 8px; color: #6c757d;">Image failed to download: {url[:100]}...</div>'
                    else:
                        app.logger.warning("No URL found in image dictionary")
                        
                elif isinstance(image_data, str) and image_data.strip():
                    app.logger.info(f"String format image data: {image_data}")
                    # Simple filename or URL
                    if image_data.startswith('http'):
                        app.logger.info(f"String URL detected, downloading: {image_data}")
                        downloaded_filename = download_image_from_url(image_data, media_files)
                        if downloaded_filename:
                            app.logger.info(f"‚úÖ Successfully downloaded from string URL: {downloaded_filename}")
                            image_content = f'''<div style="text-align: center; margin: 20px 0;">
                                <img src="{downloaded_filename}" style="max-width: 90%; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); border: 2px solid #dee2e6;">
                            </div>'''
                        else:
                            app.logger.error(f"‚ùå Failed to download from string URL: {image_data}")
                            image_content = f'<div style="text-align: center; padding: 20px; background-color: #f8f9fa; border: 2px dashed #6c757d; border-radius: 8px; color: #6c757d;">Image failed to download: {image_data[:100]}...</div>'
                    else:
                        app.logger.info(f"Local filename detected: {image_data}")
                        image_content = f'''<div style="text-align: center; margin: 20px 0;">
                            <img src="{image_data}" style="max-width: 90%; height: auto; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); border: 2px solid #dee2e6;">
                        </div>'''
                else:
                    app.logger.warning(f"Unexpected image data format: {type(image_data)} - {image_data}")
                
                app.logger.info(f"Final image_content length: {len(image_content)}")
                app.logger.info(f"Final image_content preview: {image_content[:200]}...")
            else:
                app.logger.info("No image data found in card")
            
            # Create the note
            note = genanki.Note(
                model=self.model,
                fields=[
                    front_content,
                    back_content,
                    extra_content,
                    vignette_content,
                    mnemonic_content,
                    image_content
                ],
                tags=[tag.replace(' ', '_') for tag in card_info.get('tags', [])]
            )
            
            deck.add_note(note)
        
        return deck, media_files

def generate_synaptic_recall_name(cards):
    """Generate SynapticRecall deck name based on card content analysis"""
    import re
    
    # Collect all text content from cards
    all_text = []
    for card in cards:
        front_text = card.get('front', '')
        back_text = card.get('back', '')
        tags = card.get('tags', [])
        
        all_text.extend([front_text, back_text])
        
        if isinstance(tags, list):
            all_text.extend([str(tag) for tag in tags])
        elif isinstance(tags, str):
            all_text.append(tags)
    
    # Combine all text and convert to lowercase
    combined_text = ' '.join(all_text).lower()
    
    # Medical topic keywords with priority order
    topic_keywords = {
        'spinothalamic': 'spinothalmictract',
        'spinal cord': 'spinalcord',
        'cervical enlargement': 'cervicalenlargement',
        'lumbosacral enlargement': 'lumbosacralenlargement',
        'brachial plexus': 'brachialplexus',
        'neuroanatomy': 'neuroanatomy',
        'anatomy': 'anatomy',
        'physiology': 'physiology',
        'pathology': 'pathology',
    }
    
    # Find the most relevant topic
    detected_topic = None
    for keyword, topic in topic_keywords.items():
        if keyword in combined_text:
            detected_topic = topic
            break
    
    if not detected_topic:
        detected_topic = 'medicalcards'
    
    return f"synapticrecall_{detected_topic}"

@app.route('/api/enhanced-medical', methods=['POST', 'OPTIONS'])
def api_enhanced_medical():
    """Enhanced endpoint for beautiful medical flashcards"""
    if request.method == 'OPTIONS':
        return '', 200
        
    try:
        app.logger.info("=== ENHANCED MEDICAL API CALLED ===")
        
        # Parse JSON data
        data = request.get_json(force=True)
        if not data:
            return {'error': 'No JSON data provided'}, 400
        
        app.logger.info(f"Received data: {data}")
        
        # Handle different input formats
        if isinstance(data, list):
            if len(data) > 0 and isinstance(data[0], dict) and 'cards' in data[0]:
                cards = data[0]['cards']
                deck_name = data[0].get('deck_name', None)
            else:
                cards = data
                deck_name = None
        elif isinstance(data, dict):
            cards = data.get('cards', [])
            deck_name = data.get('deck_name', None)
        else:
            return {'error': 'Invalid data format'}, 400
        
        if not cards:
            return {'error': 'No cards provided'}, 400
        
        # Generate intelligent deck name
        if not deck_name:
            base_deck_name = generate_synaptic_recall_name(cards)
        else:
            base_deck_name = deck_name
        
        timestamp = int(time.time())
        final_deck_name = f"{base_deck_name}_{timestamp}"
        
        app.logger.info(f"Processing {len(cards)} cards for deck '{final_deck_name}'")
        
        # Process with enhanced formatting
        processor = EnhancedFlashcardProcessor()
        deck, media_files = processor.process_cards(cards, final_deck_name)
        
        # Create package and save
        package = genanki.Package(deck)
        package.media_files = media_files
        
        safe_name = "".join(c for c in final_deck_name if c.isalnum() or c in (' ', '-', '_')).strip()
        if not safe_name:
            safe_name = "enhanced_medical_cards"
        
        filename = f"{safe_name}_{timestamp}.apkg"
        file_path = f"/tmp/{filename}"
        
        package.write_to_file(file_path)
        file_size = os.path.getsize(file_path)
        
        app.logger.info(f"Generated enhanced medical deck: {file_path} (size: {file_size} bytes)")
        
        download_url = f"/download/{filename}"
        full_url = f"https://flashcard-converter-haziqmakesai.replit.app{download_url}"
        
        result = {
            'success': True,
            'status': 'completed',
            'deck_name': final_deck_name,
            'cards_processed': len(cards),
            'media_files_downloaded': len(media_files),
            'file_size': file_size,
            'filename': filename,
            'download_url': download_url,
            'full_download_url': full_url,
            'message': f'Generated enhanced medical deck with {len(cards)} cards and {len(media_files)} images'
        }
        
        app.logger.info(f"SUCCESS: {result}")
        return result, 200
            
    except Exception as e:
        app.logger.error(f"ENHANCED MEDICAL API ERROR: {str(e)}")
        import traceback
        app.logger.error(f"Traceback: {traceback.format_exc()}")
        return {
            'error': 'Processing failed',
            'message': str(e),
            'traceback': traceback.format_exc()
        }, 500

# Keep existing endpoints for compatibility
@app.route('/api/health', methods=['GET'])
def api_health():
    """Health check endpoint for monitoring"""
    return jsonify({
        'status': 'healthy',
        'service': 'Enhanced Medical JSON to Anki Converter',
        'version': '4.0.0',
        'features': ['enhanced_medical_cards', 'image_download', 'click_reveal', 'medical_highlighting'],
        'timestamp': int(time.time())
    }), 200

@app.route('/download/<path:filename>')
def download_file(filename):
    """Serve generated .apkg files for download"""
    try:
        file_path = os.path.join('/tmp', filename)
        
        if not os.path.exists(file_path):
            return f"File not found: {filename}", 404
        
        return send_file(
            file_path,
            as_attachment=True,
            download_name=filename,
            mimetype='application/octet-stream'
        )
    except Exception as e:
        app.logger.error(f"Download error: {e}")
        return "Download failed", 500

@app.route('/')
def index():
    """Main page"""
    return """
    <html>
    <head><title>Enhanced Medical Anki Generator</title></head>
    <body style="font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px;">
        <h1>ü©∫ Enhanced Medical Anki Generator</h1>
        <p>Send POST requests to <code>/api/enhanced-medical</code> with your n8n JSON data.</p>
        <h3>Features:</h3>
        <ul>
            <li>‚úÖ Beautiful medical card styling</li>
            <li>‚úÖ Clinical vignettes with click-to-reveal answers</li>
            <li>‚úÖ Automatic medical term highlighting</li>
            <li>‚úÖ Image download and embedding</li>
            <li>‚úÖ Enhanced mnemonic and vignette sections</li>
        </ul>
    </body>
    </html>
    """

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)